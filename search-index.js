var searchIndex = {};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and decoding numbers in either big-endian or little-endian order.","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"BE","","A type alias for `BigEndian`.",null,null],[6,"LE","","A type alias for `LittleEndian`.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"result"}}],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i8"],"name":"result"}}],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u16"],"name":"result"}}],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i16"],"name":"result"}}],[11,"read_u24","","Reads an unsigned 24 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"result"}}],[11,"read_i24","","Reads a signed 24 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"result"}}],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u64"],"name":"result"}}],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i64"],"name":"result"}}],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["u64"],"name":"result"}}],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["i64"],"name":"result"}}],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["f32"],"name":"result"}}],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["f64"],"name":"result"}}],[11,"read_u16_into","","Reads a sequence of unsigned 16 bit integers from the underlying reader.",0,null],[11,"read_u32_into","","Reads a sequence of unsigned 32 bit integers from the underlying reader.",0,null],[11,"read_u64_into","","Reads a sequence of unsigned 64 bit integers from the underlying reader.",0,null],[11,"read_i16_into","","Reads a sequence of signed 16 bit integers from the underlying reader.",0,null],[11,"read_i32_into","","Reads a sequence of signed 32 bit integers from the underlying reader.",0,null],[11,"read_i64_into","","Reads a sequence of signed 64 bit integers from the underlying reader.",0,null],[11,"read_f32_into","","Reads a sequence of IEEE754 single-precision (4 bytes) floating point numbers from the underlying reader.",0,null],[11,"read_f32_into_unchecked","","DEPRECATED.",0,null],[11,"read_f64_into","","Reads a sequence of IEEE754 double-precision (8 bytes) floating point numbers from the underlying reader.",0,null],[11,"read_f64_into_unchecked","","DEPRECATED.",0,null],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"result"}}],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"result"}}],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i16"}],"output":{"name":"result"}}],[11,"write_u24","","Writes an unsigned 24 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i24","","Writes a signed 24 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"result"}}],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"result"}}],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"usize"}],"output":{"name":"result"}}],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"usize"}],"output":{"name":"result"}}],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"name":"result"}}],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"result"}}],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,null],[11,"read_u24","","Reads an unsigned 24 bit integer from `buf`, stored in u32.",2,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,null],[11,"write_u24","","Writes an unsigned 24 bit integer `n` to `buf`, stored in u32.",2,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,null],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,null],[11,"read_i24","","Reads a signed 24 bit integer from `buf`, stored in i32.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,null],[11,"write_i24","","Writes a signed 24 bit integer `n` to `buf`, stored in i32.",2,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,null],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",2,null],[10,"read_u16_into","","Reads unsigned 16 bit integers from `src` into `dst`.",2,null],[10,"read_u32_into","","Reads unsigned 32 bit integers from `src` into `dst`.",2,null],[10,"read_u64_into","","Reads unsigned 64 bit integers from `src` into `dst`.",2,null],[11,"read_i16_into","","Reads signed 16 bit integers from `src` to `dst`.",2,null],[11,"read_i32_into","","Reads signed 32 bit integers from `src` into `dst`.",2,null],[11,"read_i64_into","","Reads signed 64 bit integers from `src` into `dst`.",2,null],[11,"read_f32_into_unchecked","","Reads IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",2,null],[11,"read_f64_into_unchecked","","Reads IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",2,null],[10,"write_u16_into","","Writes unsigned 16 bit integers from `src` into `dst`.",2,null],[10,"write_u32_into","","Writes unsigned 32 bit integers from `src` into `dst`.",2,null],[10,"write_u64_into","","Writes unsigned 64 bit integers from `src` into `dst`.",2,null],[11,"write_i16_into","","Writes signed 16 bit integers from `src` into `dst`.",2,null],[11,"write_i32_into","","Writes signed 32 bit integers from `src` into `dst`.",2,null],[11,"write_i64_into","","Writes signed 64 bit integers from `src` into `dst`.",2,null],[11,"write_f32_into","","Writes IEEE754 single-precision (4 bytes) floating point numbers from `src` into `dst`.",2,null],[11,"write_f64_into","","Writes IEEE754 double-precision (8 bytes) floating point numbers from `src` into `dst`.",2,null],[10,"from_slice_u16","","Converts the given slice of unsigned 16 bit integers to a particular endianness.",2,null],[10,"from_slice_u32","","Converts the given slice of unsigned 32 bit integers to a particular endianness.",2,null],[10,"from_slice_u64","","Converts the given slice of unsigned 64 bit integers to a particular endianness.",2,null],[11,"from_slice_i16","","Converts the given slice of signed 16 bit integers to a particular endianness.",2,null],[11,"from_slice_i32","","Converts the given slice of signed 32 bit integers to a particular endianness.",2,null],[11,"from_slice_i64","","Converts the given slice of signed 64 bit integers to a particular endianness.",2,null],[10,"from_slice_f32","","Converts the given slice of IEEE754 single-precision (4 bytes) floating point numbers to a particular endianness.",2,null],[10,"from_slice_f64","","Converts the given slice of IEEE754 double-precision (8 bytes) floating point numbers to a particular endianness.",2,null],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bigendian"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",3,null],[11,"cmp","","",3,{"inputs":[{"name":"self"},{"name":"bigendian"}],"output":{"name":"ordering"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"bigendian"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"self"},{"name":"bigendian"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"bigendian"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"littleendian"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",4,null],[11,"cmp","","",4,{"inputs":[{"name":"self"},{"name":"littleendian"}],"output":{"name":"ordering"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"littleendian"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",4,{"inputs":[{"name":"self"},{"name":"littleendian"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"littleendian"}}],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[11,"write_uint","","",3,null],[11,"read_u16_into","","",3,null],[11,"read_u32_into","","",3,null],[11,"read_u64_into","","",3,null],[11,"write_u16_into","","",3,null],[11,"write_u32_into","","",3,null],[11,"write_u64_into","","",3,null],[11,"from_slice_u16","","",3,null],[11,"from_slice_u32","","",3,null],[11,"from_slice_u64","","",3,null],[11,"from_slice_f32","","",3,null],[11,"from_slice_f64","","",3,null],[11,"read_u16","","",4,null],[11,"read_u32","","",4,null],[11,"read_u64","","",4,null],[11,"read_uint","","",4,null],[11,"write_u16","","",4,null],[11,"write_u32","","",4,null],[11,"write_u64","","",4,null],[11,"write_uint","","",4,null],[11,"read_u16_into","","",4,null],[11,"read_u32_into","","",4,null],[11,"read_u64_into","","",4,null],[11,"write_u16_into","","",4,null],[11,"write_u32_into","","",4,null],[11,"write_u64_into","","",4,null],[11,"from_slice_u16","","",4,null],[11,"from_slice_u32","","",4,null],[11,"from_slice_u64","","",4,null],[11,"from_slice_f32","","",4,null],[11,"from_slice_f64","","",4,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"result"}}],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i8"],"name":"result"}}],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u16"],"name":"result"}}],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i16"],"name":"result"}}],[11,"read_u24","","Reads an unsigned 24 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"result"}}],[11,"read_i24","","Reads a signed 24 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"result"}}],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["u64"],"name":"result"}}],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["i64"],"name":"result"}}],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["u64"],"name":"result"}}],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["i64"],"name":"result"}}],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["f32"],"name":"result"}}],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from the underlying reader.",0,{"inputs":[{"name":"self"}],"output":{"generics":["f64"],"name":"result"}}],[11,"read_u16_into","","Reads a sequence of unsigned 16 bit integers from the underlying reader.",0,null],[11,"read_u32_into","","Reads a sequence of unsigned 32 bit integers from the underlying reader.",0,null],[11,"read_u64_into","","Reads a sequence of unsigned 64 bit integers from the underlying reader.",0,null],[11,"read_i16_into","","Reads a sequence of signed 16 bit integers from the underlying reader.",0,null],[11,"read_i32_into","","Reads a sequence of signed 32 bit integers from the underlying reader.",0,null],[11,"read_i64_into","","Reads a sequence of signed 64 bit integers from the underlying reader.",0,null],[11,"read_f32_into","","Reads a sequence of IEEE754 single-precision (4 bytes) floating point numbers from the underlying reader.",0,null],[11,"read_f32_into_unchecked","","DEPRECATED.",0,null],[11,"read_f64_into","","Reads a sequence of IEEE754 double-precision (8 bytes) floating point numbers from the underlying reader.",0,null],[11,"read_f64_into_unchecked","","DEPRECATED.",0,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"result"}}],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"result"}}],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i16"}],"output":{"name":"result"}}],[11,"write_u24","","Writes an unsigned 24 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i24","","Writes a signed 24 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"result"}}],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"result"}}],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"usize"}],"output":{"name":"result"}}],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"usize"}],"output":{"name":"result"}}],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"name":"result"}}],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to the underlying writer.",1,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"result"}}]],"paths":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["num_traits"] = {"doc":"Numeric traits for generic mathematics","items":[[3,"ParseFloatError","num_traits","",null,null],[12,"kind","","",0,null],[4,"FloatErrorKind","","",null,null],[13,"Empty","","",1,null],[13,"Invalid","","",1,null],[5,"clamp","","A value bounded by a minimum and a maximum",null,{"inputs":[{"name":"t"},{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[0,"identities","","",null,null],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",null,{"inputs":[],"output":{"name":"t"}}],[5,"one","","Returns the multiplicative identity, `1`.",null,{"inputs":[],"output":{"name":"t"}}],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`.",2,{"inputs":[],"output":{"name":"self"}}],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",3,{"inputs":[],"output":{"name":"self"}}],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative identity.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"sign","num_traits","",null,null],[5,"abs","num_traits::sign","Computes the absolute value.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"abs_sub","","The positive difference of two numbers.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"signum","","Returns the sign of the number.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative).",null,null],[10,"abs","","Computes the absolute value.",4,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"abs_sub","","The positive difference of two numbers.",4,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"signum","","Returns the sign of the number.",4,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[0,"ops","num_traits","",null,null],[0,"saturating","num_traits::ops","",null,null],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at the numeric bounds instead of overflowing.",5,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating at the numeric bounds instead of overflowing.",5,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[0,"checked","num_traits::ops","",null,null],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping around on overflow.",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is returned.",6,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.",7,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, `None` is returned.",8,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by zero. If any of that happens, `None` is returned.",9,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[8,"CheckedShl","","Performs a left shift that returns `None` on overflow.",null,null],[10,"checked_shl","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",10,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"option"}}],[8,"CheckedShr","","Performs a right shift that returns `None` on overflow.",null,null],[10,"checked_shr","","Shifts a number to the left, checking for overflow. If overflow happens, `None` is returned.",11,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"option"}}],[0,"wrapping","num_traits::ops","",null,null],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of the type.",12,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary of the type.",13,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary of the type.",14,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[0,"inv","num_traits::ops","",null,null],[8,"Inv","num_traits::ops::inv","Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.",null,null],[16,"Output","","The result after applying the operator.",15,null],[10,"inv","","Returns the multiplicative inverse of `self`.",15,null],[0,"bounds","num_traits","",null,null],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",16,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","returns the largest finite number this type can represent",16,{"inputs":[],"output":{"name":"self"}}],[0,"float","num_traits","",null,null],[8,"FloatCore","num_traits::float","Generic trait for floating point numbers that works with `no_std`.",null,null],[10,"infinity","","Returns positive infinity.",17,{"inputs":[],"output":{"name":"self"}}],[10,"neg_infinity","","Returns negative infinity.",17,{"inputs":[],"output":{"name":"self"}}],[10,"nan","","Returns NaN.",17,{"inputs":[],"output":{"name":"self"}}],[10,"neg_zero","","Returns `-0.0`.",17,{"inputs":[],"output":{"name":"self"}}],[10,"min_value","","Returns the smallest finite value that this type can represent.",17,{"inputs":[],"output":{"name":"self"}}],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",17,{"inputs":[],"output":{"name":"self"}}],[10,"epsilon","","Returns epsilon, a small positive value.",17,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","Returns the largest finite value that this type can represent.",17,{"inputs":[],"output":{"name":"self"}}],[11,"is_nan","","Returns `true` if the number is NaN.",17,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_infinite","","Returns `true` if the number is infinite.",17,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",17,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_normal","","Returns `true` if the number is neither zero, infinite, subnormal or NaN.",17,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",17,{"inputs":[{"name":"self"}],"output":{"name":"fpcategory"}}],[11,"floor","","Returns the largest integer less than or equal to a number.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"ceil","","Returns the smallest integer greater than or equal to a number.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"trunc","","Return the integer part of a number.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"fract","","Returns the fractional part of a number.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"abs","","Computes the absolute value of `self`. Returns `FloatCore::nan()` if the number is `FloatCore::nan()`.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"signum","","Returns a number that represents the sign of `self`.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and `FloatCore::infinity()`, and since Rust 1.20 also `FloatCore::nan()`.",17,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and `FloatCore::neg_infinity()`, and since Rust 1.20 also `-FloatCore::nan()`.",17,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"min","","Returns the minimum of the two numbers.",17,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"max","","Returns the maximum of the two numbers.",17,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the number.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"powi","","Raise a number to an integer power.",17,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"self"}}],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",17,null],[8,"Float","","Generic trait for floating point numbers",null,null],[10,"nan","","Returns the `NaN` value.",18,{"inputs":[],"output":{"name":"self"}}],[10,"infinity","","Returns the infinite value.",18,{"inputs":[],"output":{"name":"self"}}],[10,"neg_infinity","","Returns the negative infinite value.",18,{"inputs":[],"output":{"name":"self"}}],[10,"neg_zero","","Returns `-0.0`.",18,{"inputs":[],"output":{"name":"self"}}],[10,"min_value","","Returns the smallest finite value that this type can represent.",18,{"inputs":[],"output":{"name":"self"}}],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",18,{"inputs":[],"output":{"name":"self"}}],[11,"epsilon","","Returns epsilon, a small positive value.",18,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","Returns the largest finite value that this type can represent.",18,{"inputs":[],"output":{"name":"self"}}],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",18,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",18,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",18,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",18,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",18,{"inputs":[{"name":"self"}],"output":{"name":"fpcategory"}}],[10,"floor","","Returns the largest integer less than or equal to a number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"trunc","","Return the integer part of a number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"fract","","Returns the fractional part of a number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"signum","","Returns a number that represents the sign of `self`.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and since Rust 1.20 also `Float::nan()`.",18,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`.",18,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This produces a more accurate result with better performance than a separate multiplication operation followed by an add.",18,{"inputs":[{"name":"self"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"powi","","Raise a number to an integer power.",18,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"self"}}],[10,"powf","","Raise a number to a floating point power.",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sqrt","","Take the square root of a number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"exp","","Returns `e^(self)`, (the exponential function).",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"exp2","","Returns `2^(self)`.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ln","","Returns the natural logarithm of the number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"log2","","Returns the base 2 logarithm of the number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"log10","","Returns the base 10 logarithm of the number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"to_degrees","","Converts radians to degrees.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"to_radians","","Converts degrees to radians.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"max","","Returns the maximum of the two numbers.",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"min","","Returns the minimum of the two numbers.",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"abs_sub","","The positive difference of two numbers.",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"cbrt","","Take the cubic root of a number.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sin","","Computes the sine of a number (in radians).",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"cos","","Computes the cosine of a number (in radians).",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"tan","","Computes the tangent of a number (in radians).",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",18,null],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"sinh","","Hyperbolic sine function.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"cosh","","Hyperbolic cosine function.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"tanh","","Hyperbolic tangent function.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"asinh","","Inverse hyperbolic sine function.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"acosh","","Inverse hyperbolic cosine function.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atanh","","Inverse hyperbolic tangent function.",18,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`.",18,null],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_1_PI","","Return `1.0 / π`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_2_PI","","Return `2.0 / π`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_2","","Return `π / 2.0`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_3","","Return `π / 3.0`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_4","","Return `π / 4.0`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_6","","Return `π / 6.0`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_8","","Return `π / 8.0`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"LN_10","","Return `ln(10.0)`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"LN_2","","Return `ln(2.0)`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"LOG10_E","","Return `log10(e)`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"LOG2_E","","Return `log2(e)`.",19,{"inputs":[],"output":{"name":"self"}}],[10,"PI","","Return Archimedes’ constant.",19,{"inputs":[],"output":{"name":"self"}}],[10,"SQRT_2","","Return `sqrt(2.0)`.",19,{"inputs":[],"output":{"name":"self"}}],[0,"real","num_traits","",null,null],[8,"Real","num_traits::real","A trait for real number types that do not necessarily have floating-point-specific characteristics such as NaN and infinity.",null,null],[10,"min_value","","Returns the smallest finite value that this type can represent.",20,{"inputs":[],"output":{"name":"self"}}],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",20,{"inputs":[],"output":{"name":"self"}}],[10,"epsilon","","Returns epsilon, a small positive value.",20,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","Returns the largest finite value that this type can represent.",20,{"inputs":[],"output":{"name":"self"}}],[10,"floor","","Returns the largest integer less than or equal to a number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"trunc","","Return the integer part of a number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"fract","","Returns the fractional part of a number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"signum","","Returns a number that represents the sign of `self`.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and with newer versions of Rust `f64::NAN`.",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This produces a more accurate result with better performance than a separate multiplication operation followed by an add.",20,{"inputs":[{"name":"self"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"powi","","Raise a number to an integer power.",20,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"self"}}],[10,"powf","","Raise a number to a real number power.",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sqrt","","Take the square root of a number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"exp","","Returns `e^(self)`, (the exponential function).",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"exp2","","Returns `2^(self)`.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ln","","Returns the natural logarithm of the number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"log2","","Returns the base 2 logarithm of the number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"log10","","Returns the base 10 logarithm of the number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"to_degrees","","Converts radians to degrees.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"to_radians","","Converts degrees to radians.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"max","","Returns the maximum of the two numbers.",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"min","","Returns the minimum of the two numbers.",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"abs_sub","","The positive difference of two numbers.",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"cbrt","","Take the cubic root of a number.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sin","","Computes the sine of a number (in radians).",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"cos","","Computes the cosine of a number (in radians).",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"tan","","Computes the tangent of a number (in radians).",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",20,null],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"sinh","","Hyperbolic sine function.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"cosh","","Hyperbolic cosine function.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"tanh","","Hyperbolic tangent function.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"asinh","","Inverse hyperbolic sine function.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"acosh","","Inverse hyperbolic cosine function.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atanh","","Inverse hyperbolic tangent function.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[0,"cast","num_traits","",null,null],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",null,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["isize"],"name":"option"}}],[11,"to_i8","","Converts the value of `self` to an `i8`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["i8"],"name":"option"}}],[11,"to_i16","","Converts the value of `self` to an `i16`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["i16"],"name":"option"}}],[11,"to_i32","","Converts the value of `self` to an `i32`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"option"}}],[10,"to_i64","","Converts the value of `self` to an `i64`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["i64"],"name":"option"}}],[11,"to_usize","","Converts the value of `self` to a `usize`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"to_u8","","Converts the value of `self` to an `u8`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"option"}}],[11,"to_u16","","Converts the value of `self` to an `u16`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["u16"],"name":"option"}}],[11,"to_u32","","Converts the value of `self` to an `u32`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"option"}}],[10,"to_u64","","Converts the value of `self` to an `u64`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["u64"],"name":"option"}}],[11,"to_f32","","Converts the value of `self` to an `f32`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["f32"],"name":"option"}}],[11,"to_f64","","Converts the value of `self` to an `f64`.",21,{"inputs":[{"name":"self"}],"output":{"generics":["f64"],"name":"option"}}],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the value cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"isize"}],"output":{"name":"option"}}],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"i8"}],"output":{"name":"option"}}],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"i16"}],"output":{"name":"option"}}],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"i32"}],"output":{"name":"option"}}],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"i64"}],"output":{"name":"option"}}],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"f32"}],"output":{"name":"option"}}],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the type cannot be represented by this value, the `None` is returned.",22,{"inputs":[{"name":"f64"}],"output":{"name":"option"}}],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted into a primitive via the `ToPrimitive` trait.",23,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[8,"AsPrimitive","","A generic interface for casting between machine scalars with the `as` operator, which admits narrowing and precision loss. Implementers of this trait AsPrimitive should behave like a primitive numeric type (e.g. a newtype around another primitive), and the intended conversion must never fail.",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",24,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[0,"int","num_traits","",null,null],[8,"PrimInt","num_traits::int","",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",25,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",25,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation of `self`.",25,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of `self`.",25,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping the truncated bits to the end of the resulting integer.",25,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping the truncated bits to the beginning of the resulting integer.",25,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",25,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying the \"sign bit\" in the most significant bits even for unsigned types.",25,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling zeros in the least significant bits.",25,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling zeros in the most significant bits.",25,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[10,"swap_bytes","","Reverses the byte order of the integer.",25,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"from_be","","Convert an integer from big endian to the target's endianness.",25,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"from_le","","Convert an integer from little endian to the target's endianness.",25,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"to_be","","Convert `self` to big endian from the target's endianness.",25,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"to_le","","Convert `self` to little endian from the target's endianness.",25,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",25,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[0,"pow","num_traits","",null,null],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation by squaring.",null,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"t"}}],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",null,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"option"}}],[8,"Pow","","Binary operator for raising a value to a power.",null,null],[16,"Output","","The result after applying the operator.",26,null],[10,"pow","","Returns `self` to the power `rhs`.",26,null],[8,"Num","num_traits","The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.",null,null],[16,"FromStrRadixErr","","",27,null],[10,"from_str_radix","","Convert from a string and radix <= 36.",27,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[8,"NumOps","","The trait for types implementing basic numeric operations",null,null],[8,"NumRef","","The trait for `Num` types which also implement numeric operations taking the second operand by reference.",null,null],[8,"RefNum","","The trait for references which implement numeric operations, taking the second operand either by value or by reference.",null,null],[8,"NumAssignOps","","The trait for types implementing numeric assignment operators (like `+=`).",null,null],[8,"NumAssign","","The trait for `Num` types which also implement assignment operators.",null,null],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement assignment operations taking the second operand by reference.",null,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[3,"ParseFloatError"],[4,"FloatErrorKind"],[8,"Zero"],[8,"One"],[8,"Signed"],[8,"Saturating"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"Inv"],[8,"Bounded"],[8,"FloatCore"],[8,"Float"],[8,"FloatConst"],[8,"Real"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"PrimInt"],[8,"Pow"],[8,"Num"]]};
searchIndex["succinct"] = {"doc":"Succinct data structures for Rust.","items":[[3,"BitVector","succinct","Uncompressed vector of bits.",null,null],[3,"IntVector","","Uncompressed vector of k-bit unsigned integers.",null,null],[3,"JacobsonRank","","Jacobson’s rank structure for fast rank queries over a `BitVec`.",null,null],[3,"Rank9","","Vigna’s rank structure for fast rank queries over a `BitVec`.",null,null],[3,"BinSearchSelect","","Performs a select query by binary searching rank queries.",null,null],[0,"broadword","","Broadword operations treating `u64` as a parallel vector.",null,null],[3,"Broadword","succinct::broadword","Newtype for treating a `u64` as a rank or select structure.",null,null],[12,"0","","",0,null],[5,"count_ones","","Counts the number of ones in a `u64`.",null,{"inputs":[{"name":"u64"}],"output":{"name":"usize"}}],[5,"select1","","Finds the index of the `r`th one bit in `x`.",null,{"inputs":[{"name":"usize"},{"name":"u64"}],"output":{"generics":["usize"],"name":"option"}}],[5,"select1_raw","","Finds the index of the `r`th one bit in `x`, returning 72 when not found.",null,{"inputs":[{"name":"usize"},{"name":"u64"}],"output":{"name":"usize"}}],[5,"u_le8","","Parallel ≤, treating a `u64` as a vector of 8 `u8`s.",null,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"u64"}}],[5,"le8","","Parallel ≤, treating a `u64` as a vector of 8 `i8`s.",null,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"u64"}}],[5,"u_nz8","","Parallel >0, treating a `u64` as a vector of 8 `u8`s.",null,{"inputs":[{"name":"u64"}],"output":{"name":"u64"}}],[17,"L8","","Has the lowest bit of every byte set: `0x0101_0101_0101_0101`.",null,null],[17,"H8","","Has the highest bit of every byte set: `0x8080_8080_8080_8080`.",null,null],[11,"rank1","","",0,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"rank","","",0,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":{"name":"u64"}}],[11,"limit","","",0,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"select1","","",0,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"generics":["u64"],"name":"option"}}],[0,"coding","succinct","Codes for data compression.",null,null],[6,"Result","succinct::coding","A specialized `Result` type for I/O operations.",null,null],[3,"Unary","","Encodes n as n zeroes followed by a one.",null,null],[3,"Elias","","An Elias code.",null,null],[12,"0","","",1,null],[3,"Omega","","An Elias omega code iterates the Elias encoding.",null,null],[3,"Fibonacci","","A Fibonacci code.",null,null],[3,"Comma","","`Comma(n)` encodes in base 2n - 1, using n bits per digit.",null,null],[12,"0","","",2,null],[3,"Lift0","","Lifts any code by adding one to each encoded value, and subtracting one from each decoded value.",null,null],[12,"0","","",3,null],[11,"encode","","",4,{"inputs":[{"name":"self"},{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[11,"decode","","",4,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"generics":["option"],"name":"result"}}],[11,"encode","","",1,{"inputs":[{"name":"self"},{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[11,"decode","","",1,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"generics":["option"],"name":"result"}}],[11,"encode","","",5,{"inputs":[{"name":"self"},{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[11,"decode","","",5,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"generics":["option"],"name":"result"}}],[11,"encode","","",6,{"inputs":[{"name":"self"},{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[11,"decode","","",6,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"generics":["option"],"name":"result"}}],[11,"encode","","",2,{"inputs":[{"name":"self"},{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[11,"decode","","",2,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"generics":["option"],"name":"result"}}],[11,"encode","","",3,{"inputs":[{"name":"self"},{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[11,"decode","","",3,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"generics":["option"],"name":"result"}}],[6,"Gamma","","An Elias gamma code encodes the header in unary.",null,null],[6,"Delta","","An Elias delta code encodes the header using the Elias gamma code.",null,null],[17,"GAMMA","","An instance of `Gamma`.",null,null],[17,"DELTA","","An instance of `Delta`.",null,null],[17,"COMMA","","`Comma(2)` encodes in base 3.",null,null],[8,"UniversalCode","","A universal code lets us encode arbitrary sized integers in a self-delimiting code.",null,null],[10,"encode","","Writes `value` to `sink`.",7,{"inputs":[{"name":"self"},{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[10,"decode","","Reads a value from `source`.",7,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"generics":["option"],"name":"result"}}],[0,"storage","succinct","Traits describing how bits and arrays of bits are stored.",null,null],[3,"Address","succinct::storage","Represents the address of a bit, broken into a block component and a bit offset component.",null,null],[12,"block_index","","The index of the block containing the bit in question.",8,null],[12,"bit_offset","","The position of the bit in question within its block.",8,null],[8,"BlockType","","Types that can be used for `IntVector` and `BitVector` storage.",null,null],[11,"nbits","","The number of bits in a block.",9,{"inputs":[],"output":{"name":"usize"}}],[11,"div_nbits","","Returns `index / Self::nbits()`, computed by shifting.",9,{"inputs":[{"name":"u64"}],"output":{"name":"usize"}}],[11,"checked_div_nbits","","Returns `index / Self::nbits()`, computed by shifting.",9,{"inputs":[{"name":"u64"}],"output":{"generics":["usize"],"name":"option"}}],[11,"ceil_div_nbits","","Returns `index / Self::nbits()` rounded up, computed by shifting.",9,{"inputs":[{"name":"u64"}],"output":{"name":"usize"}}],[11,"checked_ceil_div_nbits","","Returns `index / Self::nbits()` rounded up, computed by shifting.",9,{"inputs":[{"name":"u64"}],"output":{"generics":["usize"],"name":"option"}}],[11,"mod_nbits","","Returns `index % Self::nbits()`, computed by masking.",9,{"inputs":[{"name":"u64"}],"output":{"name":"usize"}}],[11,"mul_nbits","","Returns `index * Self::nbits()`, computed by shifting.",9,{"inputs":[{"name":"usize"}],"output":{"name":"u64"}}],[11,"last_block_bits","","Computes how many bits are in the last block of an array of `len` bits.",9,{"inputs":[{"name":"u64"}],"output":{"name":"usize"}}],[11,"lg_nbits","","Log-base-2 of the number of bits in a block.",9,{"inputs":[],"output":{"name":"usize"}}],[11,"lg_nbits_mask","","Mask with the lowest-order `lg_nbits()` set.",9,{"inputs":[],"output":{"name":"result"}}],[11,"low_mask","","The bit mask consisting of `Self::nbits() - element_bits` zeroes followed by `element_bits` ones.",9,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"nth_mask","","The bit mask with the `bit_index`th bit set.",9,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"get_bit","","Extracts the value of the `bit_index`th bit.",9,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"with_bit","","Functionally updates the value of the `bit_index`th bit to `bit_value`.",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"bool"}],"output":{"name":"self"}}],[11,"get_bits","","Extracts `len` bits starting at bit offset `start`.",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"with_bits","","Functionally updates `len` bits to `value` starting at offset `start`.",9,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"self"}],"output":{"name":"self"}}],[11,"ceil_lg","","Returns the smallest number `n` such that `2.pow(n) >= self`.",9,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"floor_lg","","Returns the largest number `n` such that `2.pow(n) <= self`.",9,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"ceil_div","","Returns the smallest number `n` such that `n * divisor >= self`.",9,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"read_block","","Reads a block with the specified endianness.",9,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[10,"write_block","","Writes a block with the specified endianness.",9,{"inputs":[{"name":"self"},{"name":"w"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"address"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"address"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"address"}],"output":{"name":"bool"}}],[11,"cmp","","",8,{"inputs":[{"name":"self"},{"name":"address"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",8,{"inputs":[{"name":"self"},{"name":"address"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",8,{"inputs":[{"name":"self"},{"name":"address"}],"output":{"name":"bool"}}],[11,"le","","",8,{"inputs":[{"name":"self"},{"name":"address"}],"output":{"name":"bool"}}],[11,"gt","","",8,{"inputs":[{"name":"self"},{"name":"address"}],"output":{"name":"bool"}}],[11,"ge","","",8,{"inputs":[{"name":"self"},{"name":"address"}],"output":{"name":"bool"}}],[11,"hash","","",8,null],[11,"new","","Creates an `Address` for the given bit index for storage in block type `Block`.",8,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"bit_index","","Converts an `Address` back into a raw bit index.",8,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[0,"stream","succinct","Bit-oriented streams for coding.",null,null],[3,"BitBuffer","succinct::stream","A bit buffer can be used to read bits from or write bits to an underlying bit vector.",null,null],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"bitbuffer"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new, empty bit buffer.",10,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Creates a new, empty bit buffer with the given capacity (in bits) preallocated.",10,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"from","","Creates a new bit buffer for reading from a bit vector.",10,{"inputs":[{"name":"inner"}],"output":{"name":"self"}}],[11,"append","","Creates a new bit buffer for appending to a bit vector.",10,{"inputs":[{"name":"inner"}],"output":{"name":"self"}}],[11,"seek","","Moves the position for the next read or write.",10,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"result"}}],[11,"into_inner","","Returns the bit vector underlying the bit buffer.",10,{"inputs":[{"name":"self"}],"output":{"name":"inner"}}],[11,"inner","","Gives access to the bit vector underlying the bit buffer.",10,{"inputs":[{"name":"self"}],"output":{"name":"inner"}}],[11,"position","","The position in the bit buffer where the next read or write will occur.",10,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"block_len","","",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"bit_len","","",10,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"get_block","","",10,null],[11,"set_block","","",10,null],[11,"read_bit","","",10,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"result"}}],[11,"write_bit","","",10,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[8,"BitRead","","Allows reading bits from a source.",null,null],[10,"read_bit","","Reads a single bit from the source.",11,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"result"}}],[11,"read_int","","Reads `nbits` bits as an integer, least-significant bit first.",11,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["option"],"name":"result"}}],[11,"read_int_be","","Reads `nbits` bits as an integer, most-significant bit first.",11,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["option"],"name":"result"}}],[8,"BitWrite","","Allows writing bits to a sink.",null,null],[10,"write_bit","","Writes a single bit to the sink.",12,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"write_int","","Writes the lower `nbits` of `value`, least-significant first.",12,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"n"}],"output":{"name":"result"}}],[11,"write_int_be","","Writes the lower `nbits` of `value`, most-significant first.",12,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"n"}],"output":{"name":"result"}}],[0,"bit_vec","succinct","Bit vector interfaces and implementations.",null,null],[3,"BitVector","succinct::bit_vec","Uncompressed vector of bits.",null,null],[3,"Iter","","Iterator over `BitVector`.",null,null],[3,"BitSlice","","A borrowed slice of a bit vector.",null,null],[3,"BitSliceMut","","A borrowed, mutable slice of a bit vector.",null,null],[11,"clone","succinct","",13,{"inputs":[{"name":"self"}],"output":{"name":"bitvector"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"bitvector"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"bitvector"}],"output":{"name":"bool"}}],[11,"cmp","","",13,{"inputs":[{"name":"self"},{"name":"bitvector"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",13,{"inputs":[{"name":"self"},{"name":"bitvector"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",13,{"inputs":[{"name":"self"},{"name":"bitvector"}],"output":{"name":"bool"}}],[11,"le","","",13,{"inputs":[{"name":"self"},{"name":"bitvector"}],"output":{"name":"bool"}}],[11,"gt","","",13,{"inputs":[{"name":"self"},{"name":"bitvector"}],"output":{"name":"bool"}}],[11,"ge","","",13,{"inputs":[{"name":"self"},{"name":"bitvector"}],"output":{"name":"bool"}}],[11,"hash","","",13,null],[11,"new","","Creates a new, empty bit vector.",13,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Creates a new, empty bit vector with space allocated for `capacity` bits.",13,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"block_with_capacity","","Creates a new, empty bit vector with space allocated for `capacity` blocks.",13,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"with_fill","","Creates a new bit vector of `len` bits initialized to `value`.",13,{"inputs":[{"name":"u64"},{"name":"bool"}],"output":{"name":"self"}}],[11,"block_with_fill","","Creates a new bit vector of `block_len` blocks initialized to `value`.",13,{"inputs":[{"name":"usize"},{"name":"block"}],"output":{"name":"self"}}],[11,"capacity","","How many bits the bit vector can hold without reallocating.",13,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"block_capacity","","How many blocks the bit vector can hold without reallocating.",13,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"resize","","Resizes the bit vector to the given number of elements, filling if necessary.",13,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":null}],[11,"block_resize","","Resizes the bit vector to the given number of blocks, filling if necessary.",13,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"block"}],"output":null}],[11,"reserve","","Reserves capacity for at least `additional` more bits to be inserted.",13,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"block_reserve","","Reserves capacity for at least `additional` blocks of bits to be inserted.",13,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"reserve_exact","","Reserves capacity for at least `additional` more bits to be inserted.",13,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"block_reserve_exact","","Reserves capacity for at least `additional` more blocks of bits to be inserted.",13,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"shrink_to_fit","","Shrinks the capacity to just fit the number of elements.",13,{"inputs":[{"name":"self"}],"output":null}],[11,"truncate","","Shrinks to the given size.",13,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"block_truncate","","Shrinks to the given size in blocks.",13,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"clear","","Sets the size to 0 while retaining the allocated storage.",13,{"inputs":[{"name":"self"}],"output":null}],[11,"iter","","Returns an iterator over the bits of the bit vector",13,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"bit_len","","",13,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"get_bit","","",13,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_block","","",13,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"block"}}],[11,"set_bit","","",13,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":null}],[11,"set_block","","",13,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"block"}],"output":null}],[11,"push_bit","","",13,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"pop_bit","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"option"}}],[11,"push_block","","",13,{"inputs":[{"name":"self"},{"name":"block"}],"output":null}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_stack_only","","",13,{"inputs":[],"output":{"name":"bool"}}],[11,"heap_bytes","","",13,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"default","","",13,{"inputs":[],"output":{"name":"self"}}],[11,"clone","succinct::bit_vec","",14,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"cmp","","",14,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",14,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",14,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"le","","",14,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"gt","","",14,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"ge","","",14,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"hash","","",14,null],[11,"next","","",14,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",14,null],[11,"count","","",14,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",14,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",14,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"len","","",14,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"next_back","","",14,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bitslice"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Slices base to the specified range.",15,{"inputs":[{"name":"base"},{"name":"r"}],"output":{"name":"self"}}],[11,"slice","","Slices this slice into a subslice.",15,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"self"}}],[11,"new","","Slices base to the specified range.",16,{"inputs":[{"name":"base"},{"name":"r"}],"output":{"name":"self"}}],[11,"slice_mut","","Slices this slice into a mutable subslice.",16,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"bitslicemut"}}],[11,"slice","","Slices this slice into an immutable subslice.",16,{"inputs":[{"name":"self"},{"name":"r"}],"output":{"name":"bitslice"}}],[11,"bit_len","","",15,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"get_bit","","",15,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_bits","","",15,null],[11,"get_block","","",15,null],[11,"bit_len","","",16,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"get_bit","","",16,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_bits","","",16,null],[11,"get_block","","",16,null],[11,"set_bit","","",16,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":null}],[11,"set_bits","","",16,null],[11,"set_block","","",16,null],[11,"is_stack_only","","",15,{"inputs":[],"output":{"name":"bool"}}],[11,"heap_bytes","","",15,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_stack_only","","",16,{"inputs":[],"output":{"name":"bool"}}],[11,"heap_bytes","","",16,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"BitVec","","Read-only bit vector operations.",null,null],[16,"Block","","The underlying block type used to store the bits of the vector.",17,null],[10,"bit_len","","The length of the slice in bits.",17,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"block_len","","The length of the slice in blocks.",17,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_bit","","Gets the bit at `position`",17,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_block","","Gets the block at `position`",17,null],[11,"get_bits","","Gets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",17,null],[8,"BitVecMut","","Mutable bit vector operations that don’t affect the length.",null,null],[11,"set_bit","","Sets the bit at `position` to `value`.",18,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":null}],[11,"set_block","","Sets the block at `position` to `value`.",18,null],[11,"set_bits","","Sets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",18,null],[8,"BitVecPush","","Bit vector operations that change the length.",null,null],[10,"push_bit","","Adds the given bit to the end of the bit vector.",19,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"pop_bit","","Removes and returns the last bit, if any.",19,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"option"}}],[11,"align_block","","Pushes `value` 0 or more times until the size of the bit vector is block-aligned.",19,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"push_block","","Pushes the given block onto the end of the bit vector.",19,null],[8,"IntoRange","","Range polymorphism support.",null,null],[10,"into_range","","Instantiates a range to a structure by provided bounds where bounds are absent.",20,{"inputs":[{"name":"self"},{"name":"t"},{"name":"t"}],"output":{"name":"range"}}],[0,"int_vec","succinct","Vectors of k-bit unsigned integers.",null,null],[3,"IntVector","succinct::int_vec","Uncompressed vector of k-bit unsigned integers.",null,null],[3,"Iter","","An iterator over the elements of an `IntVector`.",null,null],[11,"clone","succinct","",21,{"inputs":[{"name":"self"}],"output":{"name":"intvector"}}],[11,"hash","","",21,null],[11,"eq","","",21,{"inputs":[{"name":"self"},{"name":"intvector"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"self"},{"name":"intvector"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",21,{"inputs":[{"name":"self"},{"name":"intvector"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",21,{"inputs":[{"name":"self"},{"name":"intvector"}],"output":{"name":"bool"}}],[11,"le","","",21,{"inputs":[{"name":"self"},{"name":"intvector"}],"output":{"name":"bool"}}],[11,"gt","","",21,{"inputs":[{"name":"self"},{"name":"intvector"}],"output":{"name":"bool"}}],[11,"ge","","",21,{"inputs":[{"name":"self"},{"name":"intvector"}],"output":{"name":"bool"}}],[11,"cmp","","",21,{"inputs":[{"name":"self"},{"name":"intvector"}],"output":{"name":"ordering"}}],[11,"new","","Creates a new integer vector.",21,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"with_capacity","","Creates a new, empty integer vector, allocating sufficient storage for `capacity` elements.",21,{"inputs":[{"name":"usize"},{"name":"u64"}],"output":{"name":"self"}}],[11,"block_with_capacity","","Creates a new, empty integer vector, allocating `block_capacity` blocks of storage.",21,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"with_fill","","Creates a new integer vector containing `len` copies of `value`.",21,{"inputs":[{"name":"usize"},{"name":"u64"},{"name":"block"}],"output":{"name":"self"}}],[11,"block_with_fill","","Creates a new integer vector containing `block_len` copies of the block `value`.",21,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"block"}],"output":{"name":"self"}}],[11,"get_random","","Returns the element at a given index, also given an arbitrary element size and bit offset.",21,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"usize"},{"name":"u64"}],"output":{"name":"block"}}],[11,"set_random","","Sets the element at a given index to a given value, also given an arbitrary element size and bit offset.",21,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"usize"},{"name":"u64"},{"name":"block"}],"output":null}],[11,"push","","Pushes an element onto the end of the vector, increasing the length by 1.",21,{"inputs":[{"name":"self"},{"name":"block"}],"output":null}],[11,"pop","","Removes and returns the last element of the vector, if present.",21,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"capacity","","The number of elements the vector can hold without reallocating.",21,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"block_capacity","","The number of blocks of elements the vector can hold without reallocating.",21,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"resize","","Resizes to the given number of elements, filling if necessary.",21,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"block"}],"output":null}],[11,"block_resize","","Resizes to the given number of blocks, filling if necessary.",21,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"block"}],"output":null}],[11,"reserve","","Reserves capacity for at least `additional` more elements to be inserted in the given `IntVector<Block>`.",21,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"block_reserve","","Reserves capacity for at least `additional` blocks of values to be inserted.",21,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"reserve_exact","","Reserves capacity for at least `additional` more elements to be inserted in the given `IntVector<Block>`.",21,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"block_reserve_exact","","Reserves capacity for at least `additional` blocks of values to be inserted.",21,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"shrink_to_fit","","Shrinks the capacity to just fit the number of elements.",21,{"inputs":[{"name":"self"}],"output":null}],[11,"truncate","","Shrinks to the given size.",21,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"block_truncate","","Shrinks to the given number of blocks.",21,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"clear","","Sets the size to 0 while retaining the allocated storage.",21,{"inputs":[{"name":"self"}],"output":null}],[11,"iter","","Gets an iterator over the elements of the vector.",21,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"is_block_sized","","True if the element size matches the block size.",21,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_aligned","","True if elements are aligned within blocks.",21,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","",21,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"get","","",21,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"block"}}],[11,"element_bits","","",21,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"set","","",21,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"block"}],"output":null}],[11,"block_len","","",21,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"bit_len","","",21,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"get_block","","",21,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"block"}}],[11,"set_block","","",21,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"block"}],"output":null}],[11,"clone","succinct::int_vec","",22,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"cmp","","",22,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",22,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",22,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"le","","",22,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"gt","","",22,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"ge","","",22,{"inputs":[{"name":"self"},{"name":"iter"}],"output":{"name":"bool"}}],[11,"hash","","",22,null],[11,"next","","",22,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",22,null],[11,"count","","",22,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",22,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",22,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"len","","",22,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"next_back","","",22,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","succinct","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_stack_only","","",21,{"inputs":[],"output":{"name":"bool"}}],[11,"heap_bytes","","",21,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"IntVec","succinct::int_vec","An immutable array of integers of limited width.",null,null],[16,"Block","","The type of primitive value to represent elements.",23,null],[10,"len","","The number of elements.",23,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"is_empty","","Is the vector empty?",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"element_bits","","The bit width of each element.",23,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"get","","Fetches the value of the `index`th element.",23,null],[8,"IntVecMut","","A mutable array of integers of limited width.",null,null],[10,"set","","Updates the value of the `index`th element.",24,null],[0,"rank","succinct","Support for fast rank queries.",null,null],[3,"JacobsonRank","succinct::rank","Jacobson’s rank structure for fast rank queries over a `BitVec`.",null,null],[3,"Rank9","","Vigna’s rank structure for fast rank queries over a `BitVec`.",null,null],[11,"clone","succinct","",25,{"inputs":[{"name":"self"}],"output":{"name":"jacobsonrank"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new rank support structure for the given bit vector.",25,{"inputs":[{"name":"store"}],"output":{"name":"self"}}],[11,"inner","","Borrows a reference to the underlying bit store.",25,{"inputs":[{"name":"self"}],"output":{"name":"store"}}],[11,"into_inner","","Returns the underlying bit store.",25,{"inputs":[{"name":"self"}],"output":{"name":"store"}}],[11,"rank","","",25,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":{"name":"u64"}}],[11,"limit","","",25,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"rank1","","",25,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"bit_len","","",25,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"block_len","","",25,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_block","","",25,null],[11,"get_bit","","",25,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_bits","","",25,null],[11,"is_stack_only","","",25,{"inputs":[],"output":{"name":"bool"}}],[11,"heap_bytes","","",25,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"rank9"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new rank9 structure.",26,{"inputs":[{"name":"store"}],"output":{"name":"self"}}],[11,"inner","","Borrows a reference to the underlying bit store.",26,{"inputs":[{"name":"self"}],"output":{"name":"store"}}],[11,"into_inner","","Returns the underlying bit store.",26,{"inputs":[{"name":"self"}],"output":{"name":"store"}}],[11,"rank1","","",26,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"rank","","",26,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":{"name":"u64"}}],[11,"limit","","",26,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"bit_len","","",26,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"block_len","","",26,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_block","","",26,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"u64"}}],[11,"get_bit","","",26,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_bits","","",26,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"usize"}],"output":{"name":"u64"}}],[11,"is_stack_only","","",26,{"inputs":[],"output":{"name":"bool"}}],[11,"heap_bytes","","",26,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"RankSupport","succinct::rank","Supports fast rank queries.",null,null],[16,"Over","","The type of value to rank.",27,null],[10,"rank","","Returns the rank of the given value at a given position.",27,null],[10,"limit","","The size of the vector being ranked.",27,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[8,"BitRankSupport","","Supports fast rank queries over `bool`s.",null,null],[11,"rank1","","Returns the rank of 1 at the given position.",28,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"rank0","","Returns the rank of 0 at the given position.",28,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[0,"select","succinct","Support for fast select queries.",null,null],[3,"BinSearchSelect","succinct::select","Performs a select query by binary searching rank queries.",null,null],[11,"new","succinct","Creates a new binary search selection support given a rank support.",29,{"inputs":[{"name":"rank"}],"output":{"name":"self"}}],[11,"inner","","Borrows a reference to the underlying rank support.",29,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"into_inner","","Returns the underlying rank structure.",29,{"inputs":[{"name":"self"}],"output":{"name":"rank"}}],[11,"bit_len","","",29,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"block_len","","",29,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_block","","",29,null],[11,"get_bit","","",29,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_bits","","",29,null],[11,"rank","","",29,null],[11,"limit","","",29,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"rank1","","",29,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"rank0","","",29,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"select1","","",29,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"generics":["u64"],"name":"option"}}],[11,"select0","","",29,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"generics":["u64"],"name":"option"}}],[11,"select","","",29,null],[11,"is_stack_only","","",29,{"inputs":[],"output":{"name":"bool"}}],[11,"heap_bytes","","",29,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"Select1Support","succinct::select","Supports selecting for 1 bits.",null,null],[10,"select1","","Returns the position of the `index`th 1 bit.",30,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"generics":["u64"],"name":"option"}}],[8,"Select0Support","","Supports selecting for 0 bits.",null,null],[10,"select0","","Returns the position of the `index`th 0 bit.",31,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"generics":["u64"],"name":"option"}}],[8,"SelectSupport","","Supports select queries over associated type `Over`.",null,null],[16,"Over","","The type of value that we can search for.",32,null],[10,"select","","Returns the position of the `index`th occurrence of `value`.",32,null],[8,"SpaceUsage","succinct","Computes the space usage of an object.",null,null],[11,"total_bytes","","Computes the size of the receiver in bytes.",33,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"is_stack_only","","Is the size of this type known statically?",33,{"inputs":[],"output":{"name":"bool"}}],[11,"stack_bytes","","Calculates the stack portion of the size of this type.",33,{"inputs":[],"output":{"name":"usize"}}],[10,"heap_bytes","","Calculates the heap portion of the size of an object.",33,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"BitVec","","Read-only bit vector operations.",null,null],[16,"Block","","The underlying block type used to store the bits of the vector.",17,null],[10,"bit_len","","The length of the slice in bits.",17,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"block_len","succinct::bit_vec","The length of the slice in blocks.",17,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_bit","","Gets the bit at `position`",17,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_block","","Gets the block at `position`",17,null],[11,"get_bits","","Gets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",17,null],[8,"BitVecMut","succinct","Mutable bit vector operations that don’t affect the length.",null,null],[11,"set_bit","succinct::bit_vec","Sets the bit at `position` to `value`.",18,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":null}],[11,"set_block","","Sets the block at `position` to `value`.",18,null],[11,"set_bits","","Sets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",18,null],[8,"BitVecPush","succinct","Bit vector operations that change the length.",null,null],[10,"push_bit","","Adds the given bit to the end of the bit vector.",19,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"pop_bit","","Removes and returns the last bit, if any.",19,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"option"}}],[11,"align_block","succinct::bit_vec","Pushes `value` 0 or more times until the size of the bit vector is block-aligned.",19,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"push_block","","Pushes the given block onto the end of the bit vector.",19,null],[8,"IntVec","succinct","An immutable array of integers of limited width.",null,null],[16,"Block","","The type of primitive value to represent elements.",23,null],[10,"len","","The number of elements.",23,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"is_empty","succinct::int_vec","Is the vector empty?",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"element_bits","succinct","The bit width of each element.",23,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"get","","Fetches the value of the `index`th element.",23,null],[8,"IntVecMut","","A mutable array of integers of limited width.",null,null],[10,"set","","Updates the value of the `index`th element.",24,null],[8,"BitRankSupport","","Supports fast rank queries over `bool`s.",null,null],[11,"rank1","succinct::rank","Returns the rank of 1 at the given position.",28,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"rank0","","Returns the rank of 0 at the given position.",28,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[8,"Select1Support","succinct","Supports selecting for 1 bits.",null,null],[10,"select1","","Returns the position of the `index`th 1 bit.",30,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"generics":["u64"],"name":"option"}}],[14,"impl_stack_only_space_usage","","Implements `SpaceUsage` for a stack-only (`Copy`) type.",null,null],[14,"impl_bit_vec_adapter","","Implements `BitVec` for a type that contains a `BitVec` field.",null,null],[14,"impl_rank_support_adapter","","Implements `RankSupport` for a type that contains a `RankSupport` field.",null,null],[14,"impl_bit_rank_support_adapter","","Implements `BitRankSupport` for a type that contains a `BitRankSupport` field.",null,null],[14,"impl_select1_support_adapter","","Implements `Select1Support` for a type that contains a `Select1Support` field.",null,null],[14,"impl_select0_support_adapter","","Implements `Select0Support` for a type that contains a `Select0Support` field.",null,null],[14,"impl_select_support_adapter","","Implements `SelectSupport` for a type that contains a `SelectSupport` field.",null,null],[11,"read_int","succinct::stream","Reads `nbits` bits as an integer, least-significant bit first.",11,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["option"],"name":"result"}}],[11,"read_int_be","","Reads `nbits` bits as an integer, most-significant bit first.",11,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["option"],"name":"result"}}],[11,"write_int","","Writes the lower `nbits` of `value`, least-significant first.",12,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"n"}],"output":{"name":"result"}}],[11,"write_int_be","","Writes the lower `nbits` of `value`, most-significant first.",12,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"n"}],"output":{"name":"result"}}],[11,"total_bytes","succinct","Computes the size of the receiver in bytes.",33,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"stack_bytes","","Calculates the stack portion of the size of this type.",33,{"inputs":[],"output":{"name":"usize"}}],[11,"block_len","succinct::bit_vec","The length of the slice in blocks.",17,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_bit","","Gets the bit at `position`",17,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"get_block","","Gets the block at `position`",17,null],[11,"get_bits","","Gets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",17,null],[11,"set_bit","","Sets the bit at `position` to `value`.",18,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"bool"}],"output":null}],[11,"set_block","","Sets the block at `position` to `value`.",18,null],[11,"set_bits","","Sets `count` bits starting at bit index `start`, interpreted as a little-endian integer.",18,null],[11,"align_block","","Pushes `value` 0 or more times until the size of the bit vector is block-aligned.",19,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"push_block","","Pushes the given block onto the end of the bit vector.",19,null],[11,"is_empty","succinct::int_vec","Is the vector empty?",23,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"rank1","succinct::rank","Returns the rank of 1 at the given position.",28,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}],[11,"rank0","","Returns the rank of 0 at the given position.",28,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"u64"}}]],"paths":[[3,"Broadword"],[3,"Elias"],[3,"Comma"],[3,"Lift0"],[3,"Unary"],[3,"Omega"],[3,"Fibonacci"],[8,"UniversalCode"],[3,"Address"],[8,"BlockType"],[3,"BitBuffer"],[8,"BitRead"],[8,"BitWrite"],[3,"BitVector"],[3,"Iter"],[3,"BitSlice"],[3,"BitSliceMut"],[8,"BitVec"],[8,"BitVecMut"],[8,"BitVecPush"],[8,"IntoRange"],[3,"IntVector"],[3,"Iter"],[8,"IntVec"],[8,"IntVecMut"],[3,"JacobsonRank"],[3,"Rank9"],[8,"RankSupport"],[8,"BitRankSupport"],[3,"BinSearchSelect"],[8,"Select1Support"],[8,"Select0Support"],[8,"SelectSupport"],[8,"SpaceUsage"]]};
initSearch(searchIndex);
